{"version":3,"sources":["../../src/coders/address.js"],"names":["constants","sizes","ripemd160","addressDecoded","addressEncoded","key","checksum","address","stringToAddress","encoded","length","Error","decode","addressToString","decoded","uint8ToHex","encode","publicKeyToAddress","publicKey","networkIdentifier","publicKeyHash","arrayBuffer","ripemdHash","update","Buffer","digest","decodedAddress","Uint8Array","copy","hash","subarray","uint8View","isValidAddress","create","checksumBegin","deepEqual","isValidEncodedAddress","err"],"mappings":";;;;;;AAgBA;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;AAEA,IAAMA,YAAY;AACjBC,QAAO;AACNC,aAAW,EADL;AAENC,kBAAgB,EAFV;AAGNC,kBAAgB,EAHV;AAINC,OAAK,EAJC;AAKNC,YAAU;AALJ;AADU,CAAlB;;AAUA;AAhCA;;;;;;;;;;;;;;;;AAiCA,IAAMC,UAAU;AACf;;;;;AAKAC,kBAAiB,kCAAW;AAC3B,MAAIR,UAAUC,KAAV,CAAgBG,cAAhB,KAAmCK,QAAQC,MAA/C,EACC,MAAMC,MAASF,OAAT,iDAAN;;AAED,SAAO,eAAOG,MAAP,CAAcH,OAAd,CAAP;AACA,EAXc;;AAaf;;;;;AAKAI,kBAAiB,kCAAW;AAC3B,MAAIb,UAAUC,KAAV,CAAgBE,cAAhB,KAAmCW,QAAQJ,MAA/C,EACC,MAAMC,MAAS,kBAAQI,UAAR,CAAmBD,OAAnB,CAAT,iDAAN;;AAED,SAAO,eAAOE,MAAP,CAAcF,OAAd,CAAP;AACA,EAvBc;;AAyBf;;;;;;AAMAG,qBAAoB,4BAACC,SAAD,EAAYC,iBAAZ,EAAkC;AACrD;AACA,MAAMC,gBAAgB,gBAASC,WAAT,CAAqBH,SAArB,CAAtB;;AAEA;AACA,MAAMI,aAAa,uBAAgBC,MAAhB,CAAuB,IAAIC,MAAJ,CAAWJ,aAAX,CAAvB,EAAkDK,MAAlD,EAAnB;;AAEA;AACA,MAAMC,iBAAiB,IAAIC,UAAJ,CAAe3B,UAAUC,KAAV,CAAgBE,cAA/B,CAAvB;AACAuB,iBAAe,CAAf,IAAoBP,iBAApB;AACA,kBAAMS,IAAN,CAAWF,cAAX,EAA2BJ,UAA3B,EAAuCtB,UAAUC,KAAV,CAAgBC,SAAvD,EAAkE,CAAlE;;AAEA;AACA,MAAM2B,OAAO,gBAASR,WAAT,CAAqBK,eAAeI,QAAf,CAAwB,CAAxB,EAA2B9B,UAAUC,KAAV,CAAgBC,SAAhB,GAA4B,CAAvD,CAArB,CAAb;AACA,kBAAM0B,IAAN,CAAWF,cAAX,EAA2B,gBAAMK,SAAN,CAAgBF,IAAhB,CAA3B,EAAkD7B,UAAUC,KAAV,CAAgBK,QAAlE,EAA4EN,UAAUC,KAAV,CAAgBC,SAAhB,GAA4B,CAAxG;;AAEA,SAAOwB,cAAP;AACA,EAhDc;;AAkDf;;;;;AAKAM,iBAAgB,iCAAW;AAC1B,MAAMH,OAAO,gBAASI,MAAT,EAAb;AACA,MAAMC,gBAAgBlC,UAAUC,KAAV,CAAgBE,cAAhB,GAAiCH,UAAUC,KAAV,CAAgBK,QAAvE;AACAuB,OAAKN,MAAL,CAAYT,QAAQgB,QAAR,CAAiB,CAAjB,EAAoBI,aAApB,CAAZ;AACA,MAAM5B,WAAW,IAAIqB,UAAJ,CAAe3B,UAAUC,KAAV,CAAgBK,QAA/B,CAAjB;AACA,kBAAMsB,IAAN,CAAWtB,QAAX,EAAqB,gBAAMyB,SAAN,CAAgBF,KAAKR,WAAL,EAAhB,CAArB,EAA0DrB,UAAUC,KAAV,CAAgBK,QAA1E;AACA,SAAO,gBAAM6B,SAAN,CAAgB7B,QAAhB,EAA0BQ,QAAQgB,QAAR,CAAiBI,aAAjB,CAA1B,CAAP;AACA,EA9Dc;;AAgEf;;;;;AAKAE,wBAAuB,wCAAW;AACjC,MAAIpC,UAAUC,KAAV,CAAgBG,cAAhB,KAAmCK,QAAQC,MAA/C,EACC,OAAO,KAAP;;AAED,MAAI;AACH,OAAMI,UAAUP,QAAQC,eAAR,CAAwBC,OAAxB,CAAhB;AACA,UAAOF,QAAQyB,cAAR,CAAuBlB,OAAvB,CAAP;AACA,GAHD,CAGE,OAAOuB,GAAP,EAAY;AACb,UAAO,KAAP;AACA;AACD;AA/Ec,CAAhB;;kBAkFe9B,O","file":"address.js","sourcesContent":["/*\n * Copyright 2018 NEM\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { sha3_256 } from 'js-sha3';\nimport Ripemd160 from 'ripemd160';\nimport array from './array';\nimport base32 from './base32';\nimport convert from './convert';\n\nconst constants = {\n\tsizes: {\n\t\tripemd160: 20,\n\t\taddressDecoded: 25,\n\t\taddressEncoded: 40,\n\t\tkey: 32,\n\t\tchecksum: 4\n\t}\n};\n\n/** @exports coders/address */\nconst address = {\n\t/**\n\t * Converts an encoded address string to a decoded address.\n\t * @param {string} encoded The encoded address string.\n\t * @returns {Uint8Array} The decoded address corresponding to the input.\n\t */\n\tstringToAddress: encoded => {\n\t\tif (constants.sizes.addressEncoded !== encoded.length)\n\t\t\tthrow Error(`${encoded} does not represent a valid encoded address`);\n\n\t\treturn base32.decode(encoded);\n\t},\n\n\t/**\n\t * Converts a decoded address to an encoded address string.\n\t * @param {Uint8Array} decoded The decoded address.\n\t * @returns {string} The encoded address string corresponding to the input.\n\t */\n\taddressToString: decoded => {\n\t\tif (constants.sizes.addressDecoded !== decoded.length)\n\t\t\tthrow Error(`${convert.uint8ToHex(decoded)} does not represent a valid decoded address`);\n\n\t\treturn base32.encode(decoded);\n\t},\n\n\t/**\n\t * Converts a public key to a decoded address for a specific network.\n\t * @param {module:crypto/keyPair~PublicKey} publicKey The public key.\n\t * @param {number} networkIdentifier The network identifier.\n\t * @returns {Uint8Array} The decoded address corresponding to the inputs.\n\t */\n\tpublicKeyToAddress: (publicKey, networkIdentifier) => {\n\t\t// step 1: sha3 hash of the public key\n\t\tconst publicKeyHash = sha3_256.arrayBuffer(publicKey);\n\n\t\t// step 2: ripemd160 hash of (1)\n\t\tconst ripemdHash = new Ripemd160().update(new Buffer(publicKeyHash)).digest();\n\n\t\t// step 3: add network identifier byte in front of (2)\n\t\tconst decodedAddress = new Uint8Array(constants.sizes.addressDecoded);\n\t\tdecodedAddress[0] = networkIdentifier;\n\t\tarray.copy(decodedAddress, ripemdHash, constants.sizes.ripemd160, 1);\n\n\t\t// step 4: concatenate (3) and the checksum of (3)\n\t\tconst hash = sha3_256.arrayBuffer(decodedAddress.subarray(0, constants.sizes.ripemd160 + 1));\n\t\tarray.copy(decodedAddress, array.uint8View(hash), constants.sizes.checksum, constants.sizes.ripemd160 + 1);\n\n\t\treturn decodedAddress;\n\t},\n\n\t/**\n\t * Determines the validity of a decoded address.\n\t * @param {Uint8Array} decoded The decoded address.\n\t * @returns {boolean} true if the decoded address is valid, false otherwise.\n\t */\n\tisValidAddress: decoded => {\n\t\tconst hash = sha3_256.create();\n\t\tconst checksumBegin = constants.sizes.addressDecoded - constants.sizes.checksum;\n\t\thash.update(decoded.subarray(0, checksumBegin));\n\t\tconst checksum = new Uint8Array(constants.sizes.checksum);\n\t\tarray.copy(checksum, array.uint8View(hash.arrayBuffer()), constants.sizes.checksum);\n\t\treturn array.deepEqual(checksum, decoded.subarray(checksumBegin));\n\t},\n\n\t/**\n\t * Determines the validity of an encoded address string.\n\t * @param {string} encoded The encoded address string.\n\t * @returns {boolean} true if the encoded address string is valid, false otherwise.\n\t */\n\tisValidEncodedAddress: encoded => {\n\t\tif (constants.sizes.addressEncoded !== encoded.length)\n\t\t\treturn false;\n\n\t\ttry {\n\t\t\tconst decoded = address.stringToAddress(encoded);\n\t\t\treturn address.isValidAddress(decoded);\n\t\t} catch (err) {\n\t\t\treturn false;\n\t\t}\n\t}\n};\n\nexport default address;\n"]}