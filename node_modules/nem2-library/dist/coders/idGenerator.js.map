{"version":3,"sources":["../../src/coders/idGenerator.js"],"names":["constants","namespace_base_id","namespace_max_depth","name_pattern","generateId","parentId","name","hash","create","update","Uint32Array","from","buffer","result","arrayBuffer","throwInvalidFqn","reason","Error","findMosaicSeparatorIndex","mosaicSeparatorIndex","lastIndexOf","extractPartName","start","size","partName","substr","test","append","path","id","length","push","split","processor","index","idGenerator","generateMosaicId","namespaceName","namespacePath","generateNamespacePath","namespaceId","substringStart"],"mappings":"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","file":"idGenerator.js","sourcesContent":["/*\n * Copyright 2018 NEM\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { sha3_256 } from 'js-sha3';\n\nconst constants = {\n\tnamespace_base_id: [0, 0],\n\tnamespace_max_depth: 3,\n\tname_pattern: /^[a-z0-9][a-z0-9-_]*$/\n};\n\nfunction generateId(parentId, name) {\n\tconst hash = sha3_256.create();\n\thash.update(Uint32Array.from(parentId).buffer);\n\thash.update(name);\n\tconst result = new Uint32Array(hash.arrayBuffer());\n\treturn [result[0], result[1]];\n}\n\nfunction throwInvalidFqn(reason, name) {\n\tthrow Error(`fully qualified id is invalid due to ${reason} (${name})`);\n}\n\nfunction findMosaicSeparatorIndex(name) {\n\tconst mosaicSeparatorIndex = name.lastIndexOf(':');\n\tif (0 > mosaicSeparatorIndex)\n\t\tthrowInvalidFqn('missing mosaic', name);\n\n\tif (0 === mosaicSeparatorIndex)\n\t\tthrowInvalidFqn('empty part', name);\n\n\treturn mosaicSeparatorIndex;\n}\n\nfunction extractPartName(name, start, size) {\n\tif (0 === size)\n\t\tthrowInvalidFqn('empty part', name);\n\n\tconst partName = name.substr(start, size);\n\tif (!constants.name_pattern.test(partName))\n\t\tthrowInvalidFqn(`invalid part name [${partName}]`, name);\n\n\treturn partName;\n}\n\nfunction append(path, id, name) {\n\tif (constants.namespace_max_depth === path.length)\n\t\tthrowInvalidFqn('too many parts', name);\n\n\tpath.push(id);\n}\n\nfunction split(name, processor) {\n\tlet start = 0;\n\tfor (let index = 0; index < name.length; ++index) {\n\t\tif ('.' === name[index]) {\n\t\t\tprocessor(start, index - start);\n\t\t\tstart = index + 1;\n\t\t}\n\t}\n\n\treturn start;\n}\n\n/** @exports coders/idGenerator */\nconst idGenerator = {\n\t/**\n\t * Generates a mosaic id given a unified mosaic name.\n\t * @param {string} name The unified mosaic name.\n\t * @returns {module:coders/uint64~uint64} The mosaic id.\n\t */\n\tgenerateMosaicId: name => {\n\t\tif (0 >= name.length)\n\t\t\tthrowInvalidFqn('having zero length', name);\n\n\t\tconst mosaicSeparatorIndex = findMosaicSeparatorIndex(name);\n\n\t\tconst namespaceName = name.substr(0, mosaicSeparatorIndex);\n\t\tconst namespacePath = idGenerator.generateNamespacePath(namespaceName);\n\t\tconst namespaceId = namespacePath[namespacePath.length - 1];\n\n\t\treturn generateId(\n\t\t\tnamespaceId,\n\t\t\textractPartName(name, mosaicSeparatorIndex + 1, name.length - mosaicSeparatorIndex - 1)\n\t\t);\n\t},\n\n\t/**\n\t * Parses a unified namespace name into a path.\n\t * @param {string} name The unified namespace name.\n\t * @returns {array<module:coders/uint64~uint64>} The namespace path.\n\t */\n\tgenerateNamespacePath: name => {\n\t\tif (0 >= name.length)\n\t\t\tthrowInvalidFqn('having zero length', name);\n\n\t\tlet namespaceId = constants.namespace_base_id;\n\t\tconst path = [];\n\t\tconst start = split(name, (substringStart, size) => {\n\t\t\tnamespaceId = generateId(namespaceId, extractPartName(name, substringStart, size));\n\t\t\tappend(path, namespaceId, name);\n\t\t});\n\n\t\tnamespaceId = generateId(namespaceId, extractPartName(name, start, name.length - start));\n\t\tappend(path, namespaceId, name);\n\t\treturn path;\n\t}\n};\n\nexport default idGenerator;\n"]}