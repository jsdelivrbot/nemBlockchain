{"version":3,"sources":["../../src/crypto/sha3Hasher.js"],"names":["getHasher","length","func","dest","data","hasher","hash","arrayBuffer","copy","uint8View","createHasher","reset","create","update","Uint8Array","hexToUint8","Error","finalize","result"],"mappings":";;;;;;AAiBA;;AACA;;;;AACA;;;;;;AAEA,SAASA,SAAT,GAAgC;AAAA,KAAbC,MAAa,uEAAJ,EAAI;;AAC/B,QAAO,EAAE,mBAAF,EAAgB,mBAAhB,GAA+BA,MAA/B,CAAP;AACA,C,CAvBD;;;;;;;;;;;;;;;;AAgBA;kBASe;AACd;;;;;;AAMAC,OAAM,cAACC,IAAD,EAAOC,IAAP,EAAaH,MAAb,EAAwB;AAC7B,MAAMI,SAASL,UAAUC,MAAV,CAAf;AACA,MAAMK,OAAOD,OAAOE,WAAP,CAAmBH,IAAnB,CAAb;AACA,kBAAMI,IAAN,CAAWL,IAAX,EAAiB,gBAAMM,SAAN,CAAgBH,IAAhB,CAAjB;AACA,EAXa;;AAad;;;;;AAKAI,eAAc,8BAAU;AACvB,MAAIJ,aAAJ;AACA,SAAO;AACNK,UAAO,iBAAM;AACZL,WAAON,UAAUC,MAAV,EAAkBW,MAAlB,EAAP;AACA,IAHK;AAINC,WAAQ,sBAAQ;AACf,QAAIT,gBAAgBU,UAApB,EACCR,KAAKO,MAAL,CAAYT,IAAZ,EADD,KAEK,IAAI,aAAa,OAAOA,IAAxB,EACJE,KAAKO,MAAL,CAAY,kBAAQE,UAAR,CAAmBX,IAAnB,CAAZ,EADI,KAGJ,MAAMY,MAAM,uBAAN,CAAN;AACD,IAXK;AAYNC,aAAU,0BAAU;AACnB,oBAAMT,IAAN,CAAWU,MAAX,EAAmB,gBAAMT,SAAN,CAAgBH,KAAKC,WAAL,EAAhB,CAAnB;AACA;AAdK,GAAP;AAgBA;AApCa,C","file":"sha3Hasher.js","sourcesContent":["/*\n * Copyright 2018 NEM\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @module crypto/sha3Hasher */\nimport { sha3_256, sha3_512 } from 'js-sha3';\nimport array from '../coders/array';\nimport convert from '../coders/convert';\n\nfunction getHasher(length = 64) {\n\treturn { 32: sha3_256, 64: sha3_512 }[length];\n}\n\nexport default {\n\t/**\n\t * Calculates the hash of data.\n\t * @param {Uint8Array} dest The computed hash destination.\n\t * @param {Uint8Array} data The data to hash.\n\t * @param {numeric} length The hash length in bytes.\n\t */\n\tfunc: (dest, data, length) => {\n\t\tconst hasher = getHasher(length);\n\t\tconst hash = hasher.arrayBuffer(data);\n\t\tarray.copy(dest, array.uint8View(hash));\n\t},\n\n\t/**\n\t * Creates a hasher object.\n\t * @param {numeric} length The hash length in bytes.\n\t * @returns {object} The hasher.\n\t */\n\tcreateHasher: length => {\n\t\tlet hash;\n\t\treturn {\n\t\t\treset: () => {\n\t\t\t\thash = getHasher(length).create();\n\t\t\t},\n\t\t\tupdate: data => {\n\t\t\t\tif (data instanceof Uint8Array)\n\t\t\t\t\thash.update(data);\n\t\t\t\telse if ('string' === typeof data)\n\t\t\t\t\thash.update(convert.hexToUint8(data));\n\t\t\t\telse\n\t\t\t\t\tthrow Error('unsupported data type');\n\t\t\t},\n\t\t\tfinalize: result => {\n\t\t\t\tarray.copy(result, array.uint8View(hash.arrayBuffer()));\n\t\t\t}\n\t\t};\n\t}\n};\n"]}